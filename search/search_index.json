{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation for pyFCM Software Suite","text":"<p>This website explains how the pyFCM software suite can be set up and used.</p>"},{"location":"#installation","title":"Installation","text":"<p>The software which is based on Python 3.10 is already pre-installed on the supplied computers.  It can be used through Python's import statement.  For example, the main class can be imported by <code>from pyFCM.process_control_module import PCM</code>.  Details and examples on initializing the class are explained here.</p>"},{"location":"#hardware-components-and-their-interaction-with-pyfcm","title":"Hardware Components and Their Interaction with pyFCM","text":"<p>The software can be used with different hardware components. There are two options on how the software interfaces  with each hardware component:</p> <ol> <li>The hardware component is supplied by Jinetics and the related software interface code is therefore also  supplied by Jinetics.</li> <li>The hardware component is sourced by the user. In this case, the interface code needs to be completed by  the user through template interface files (more details on this page).</li> </ol> <p>A list of high-level functions is available in the pyFCM suite and some of them rely on the availability of  certain hardware components. A complete list of available functions is available here.</p>"},{"location":"#software-structure","title":"Software Structure","text":"<p>The main entry point for using the pyFCM software is the process control module and its <code>PCM</code> class which has  high-level functions related to electrolyzer and/or fuel cell testing protocols. It also logs data from all  hardware components which are initialized through the software suite.  Further, it monitors certain signals that can act as kill switch conditions to shut off the system.</p> <p>Here is a full list of all software interfaces with the hardware components:</p> <ul> <li><code>electrical_control_module</code> (always provided by Jinetics)<ul> <li>For fuel cell testing: This interface works with the  main electrical unit to measure voltages/currents during fuel cell testing and set the states of  3 relays (one of which acts as an MFC shutoff). It also reads the backpressures from the backpressure  hardware (if provided by Jinetics).</li> <li>For fuel cell testing: This interface works with the  main electrical unit to measure voltages/currents during electrolyzer testing and read &amp; set the  anode and cathode gas pressures. It sets the states of relays (one of which acts as an MFC shutoff).</li> <li><code>data_acquisition_hardware</code>: This module interfaces with the data acquisition hardware provided by Jinetics.  This class is initialized and used as an input variable during initialization of  the <code>electrical_control_module</code>.</li> </ul> </li> <li><code>heater_control_module</code> (optionally provided by Jinetics): This interface is designed to measure and set up to 8 temperatures. If not provided by Jinetics, then any 8 values can be set/measured (not necessarily related to  temperature).</li> <li><code>cathode_flow_module</code> and <code>anode_flow_module</code> (for fuel cell testing; optionally provided by Jinetics): These modules set and read the flow rates of gases and water for the anode and cathode side during fuel cell testing. It is equipped  to switch between multiple gases and uses our in-house algorithm module to set the RH accurately.</li> <li><code>backpressure_module</code> (for fuel cell testing; optionally provided by Jinetics): This module sets the backpressures  of the anode and cathode during fuel cell testing.</li> <li><code>load_hardware</code> (for fuel cell and electrolyzer testing; optionally provided by Jinetics): This module manages the  load during fuel cell testing or manages the power source during electrolyzer testing. It sets voltage and currents  during testing.</li> <li><code>potentiostat_hardware</code> (for fuel cell and electrolyzer testing; optionally provided by Jinetics): This module manages the potentiostat during fuel cell and electrolyzer testing. It enables functions like cyclic voltammetry,  squarewave mode, among others.</li> </ul> <p>Furthermore, Jinetics supports additional software components (at additional charge):</p> <ul> <li><code>recipe_loading_module</code>: Enables the loading of test recipe files for ease of use and editing.</li> <li><code>data_plotting_module</code>: Live-view during data acquisition.</li> <li><code>data_analysis</code>: Analysis code for fuel cell testing protocols and detailed analysis of acquired data results.</li> <li>A graphic user interface (GUI) that enables the operation of this software without a single line of code.</li> </ul>"},{"location":"#software-safety-feature","title":"Software Safety Feature","text":"<p>In addition to hardware components with their own safety features, the pyFCM software runs a <code>Killswitch</code> process that can prematurely  terminate the test protocol and run the function <code>hardware_reset</code> which resets all gases and temperatures back to 0.  For hardware supplied by Jinetics the corresponding software modules have the following safety checks implemented:</p> <ul> <li><code>electrical_control_module</code>: The user can attach any device (e.g., a hydrogen detector) to the Jinetic's supplied electrical control unit.  Upon reading a high state (5-10 V) from the device, the <code>Killswitch</code> shutoff will be triggered.</li> <li><code>heater_control_module</code>: If temperature 1 (cell temperature) reads more than 100 C, the <code>Killswitch</code> shutoff will be triggered.</li> <li><code>cathode_flow_module</code> and <code>anode_flow_module</code>: If the measured gas flow deviates from the setpoint for an extended period of time,  the <code>Killswitch</code> shutoff thread will be triggered.</li> </ul> <p>For Custom Hardware Templates</p> <p>For modules where software templates are used (i.e., where Jinetics has not provided the hardware component), users have full flexibility  to define their own safety conditions. These conditions should be specified within the class's <code>reading</code> function so that when the user's  criteria are satisfied, <code>self.ks</code> is set to <code>True</code>.</p>"},{"location":"custom/","title":"Hardware Customization Through the pyFCM Python Interface","text":"<p>Jinetics enables the user to use their own custom hardware and supplies template Python interfaces.  The user then needs to complete the necessary class functions for their specific hardware/use case.</p> <p>One example is given below for the <code>load_hardware</code>.  The user needs to complete the functions <code>__init__</code> (any hardware initialization has to go here),  <code>pre_current</code> (anything the load has to do before setting a current), ...</p> <p>Functions can also remain empty if, for example, the hardware does not need to do anything before setting the current.  In that case just add <code>pass</code> inside the function.</p> <pre><code># Use Python 3.10\nimport time\nimport pyvisa\n\nclass CustomLoad:\n\n    def __init__(self, address: str = 'test', verbose: bool = False):\n        \"\"\"\n        Add code here that is required to initialize the load hardware.\n        :param address: Address to connect to load, something like 'USB0::....'\n        :param verbose: Variable to handle if text is printed out or not (optional)\n        \"\"\"\n        # Put your initialization code here; the example below is for pyvisa-based communication.\n        rm = pyvisa.ResourceManager()\n        self.load = rm.open_resource(address)\n        if verbose:\n            print('Load successfully initialized.', flush=True)\n\n    def pre_current(self, current_range: int = 40) -&gt; None:\n        \"\"\"\n        Put any code that needs to be run to prepare the load before setting currents.\n        :param load_current_range: Variable that determines the load range (optional variable)\n        :return: None\n        \"\"\"\n        # Code here\n        self.load.write(':SOUR:FUNC CURR')  # EXAMPLE\n\n    def set_current(self, current: float) -&gt; None:\n        \"\"\"\n        Put code that sets the current of the load.\n        :param current: Current set point\n        :return: None\n        \"\"\"\n        # Code here\n        self.load.write(':SOUR:CURR:LEV:IMM {:.2f}'.format(current))  # EXAMPLE\n\n    def post_current(self):\n        \"\"\"\n        Put any code that needs to be run at the end of current measurements (e.g. turn off load).\n        :return: None\n        \"\"\"\n        # Code here\n\n    def pre_bias(self) -&gt; None:\n        \"\"\"\n        Put any code that needs to be run to prepare the load before setting a voltage.\n        :return: None\n        \"\"\"\n        # Code here\n        self.load.write(':SOUR:FUNC VOLT')  # EXAMPLE\n\n    def set_voltage(self, voltage: float) -&gt; None:\n        \"\"\"\n        Put code that sets the bias of the load.\n        :param voltage:\n        :return: None\n        \"\"\"\n        # Code here\n        self.load.write(':SOUR:VOLT:LEV:IMM {:.2f}'.format(voltage))  # EXAMPLE\n\n    def post_bias(self) -&gt; None:\n        \"\"\"\n        Put any code that needs to be run at the end of voltage measurements (e.g. turn off load).\n        :return: None\n        \"\"\"\n        # Code here\n        self.load.write(':SOUR:SENS 0')  # EXAMPLE\n\n    def turn_on(self) -&gt; None:\n        \"\"\"\n        Code to turn on the load device.\n        :return: None\n        \"\"\"\n        # Code here\n        self.load.write(':SOUR:INP:STAT 1')  # EXAMPLE\n\n    def turn_off(self) -&gt; None:\n        \"\"\"\n        Code to turn off the load device.\n        :return: None\n        \"\"\"\n        # Code here\n        self.load.write(':SOUR:INP:STAT 0')  # EXAMPLE\n\n\nif __name__ == '__main__':\n    # Test your code by running this script\n    load = CustomLoad('USB0::.....')\n    # Testing CC mode:\n    load.pre_current(current_range=40)\n    load.set_current(0.5)\n    time.sleep(5)  # Check that current was set correctly\n    load.post_current()\n    time.sleep(5)  # Check that load is idle/turned off\n\n    # Testing CV mode:\n    load.pre_bias()\n    load.set_voltage(0.5)\n    time.sleep(5)  # Check that voltage was set correctly\n    load.post_bias()\n    time.sleep(5)  # Check that load is idle/turned off\n</code></pre>"},{"location":"functions/","title":"List of all Available Functions in the pyFCM Software Suite","text":"<p>Here is a comprehensive list of all available functions and the input variables for each. Also, it is states  which hardware components need to be initialized for each function.</p> <p>Note</p> <p>The <code>self</code> keyword is related to object-oriented programming and is not  to be filled by the user when used.</p>"},{"location":"functions/#initialization-options-of-the-pcm-class","title":"Initialization Options of the <code>PCM</code> Class","text":"<pre><code>def __init__(self,\n             heater_module: type[HeaterProtocol] | HeaterProtocol | None = None,\n             anode_module: type[AnodeProtocol] | AnodeProtocol | None = None,\n             cathode_module: type[CathodeProtocol] | CathodeProtocol | None = None,\n             power_device: type[PowerProtocol] | PowerProtocol | None = None,\n             electrical_module: type[ElectricalProtocol] | ElectricalProtocol | None = None,\n             load_module: type[LoadProtocol] | LoadProtocol | None = None,\n             potentiostat_module: type[PotentiostatProtocol] | PotentiostatProtocol | None = None,\n             backpressure_module: type[BackpressureProtocol] | BackpressureProtocol | None = None,\n             default_gas_anode: str = 'H2', default_gas_cathode: str = 'air',\n             run_basehall: bool = False, start_killswitch_thread: bool = True, run_reset_on_exit: bool = True,\n             file_output: bool = True, startup_instructions: bool = True, verbose: bool = True,\n             outdir: str | None = None, recipe_id: str | None = None, sample_id: str | None = None,\n             log_refresh_rate: float = 0.3\n             ):\n    \"\"\"\n    Initialization of the `PCM` class.\n    :param heater_module: Instance of `heater_control_module` class\n        Default: None\n    :param anode_module: Instance of `anode_flow_module` class\n        Default: None\n    :param cathode_module: Instance of `cathode_flow_module` class\n        Default: None\n    :param power_device: Instance of `power_device` class\n        Default: None\n    :param electrical_module: Instance of `electrical_control_module` class\n        Default: None\n    :param load_module: Instance of `load_hardware` class\n        Default: None\n    :param potentiostat_module: Instance of `potentiostat_hardware` class\n        Default: None\n    :param backpressure_module: Instance of `backpressure_module` class\n        Default: None\n    :param default_gas_anode: (str) Default gas when anode is reset\n        Default: 'H2'\n    :param default_gas_cathode: (str) Default gas when cathode is reset\n        Default: 'air'\n    :param run_basehall: (bool) Whether to run basehall measurement in the beginning\n        Default: False\n    :param start_killswitch_thread: (bool) Whether to start the killswitch thread in the beginning\n        Default: True\n    :param run_reset_on_exit: (bool) Whether to run reset_hardware upon exit (triggers even when ctrl+c or error)\n            Default: True\n    :param file_output: (bool) Whether to generate log files\n        Default: True\n    :param startup_instructions: (bool) Whether to list the startup instructions\n        Default: True\n    :param verbose: (bool) Whether to print out additional text\n        Default: True\n    :param outdir: (str | None) Path to output directory\n        Default: None\n    :param recipe_id: (str | None) Recipe file name/ID\n        Default: None\n    :param sample_id: (str | None) Sample file name/ID\n        Default: None\n    :param log_refresh_rate: (float) Log refresh rate in seconds\n        Default: 0.3\n    \"\"\"\n</code></pre>"},{"location":"functions/#basic-functions-only-requiring-electrical_control_module","title":"Basic Functions only Requiring <code>electrical_control_module</code>","text":"<pre><code>def start_log(self) -&gt; None:\n    \"\"\"\n    This starts the logging of data in the background\n    (automatically initiated if `file_output` of the PCM class is set to True [which is the default])\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def stop_log(self) -&gt; None:\n    \"\"\"\n    This stops/pauses the logging of data in the background\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def wait(self, duration: float, skipable: bool = False, skip_voltage: float | None = None) -&gt; None:\n    \"\"\"\n    Requires `electrical_control_module` if `skip_voltage` is specified\n    Waits for the specified duration. If `skipable` is True then this wait can be skipped by pressing\n    the `end` key on the keyboard.\n    If `skip_voltage` is specified the wait is skipped if the response voltage is less than that value.\n    :param duration: (float) Duration in seconds\n    :param skipable: (bool) Whether to be able to skip the wait (by pressing `end` key on the keyboard)\n        Default: False\n    :param skip_voltage: (float | None) Voltage that determines the skipping trigger\n        Default: None\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def log_text(self, text: str) -&gt; None:\n    \"\"\"\n    Add text to the log file.\n    :param text: (str) The text to be logged.\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def hardware_reset(self, default_gas_anode: str | None = None, default_gas_cathode: str | None = None) -&gt; None:\n    \"\"\"\n    Resets all hardware components that were initialized.\n    :param default_gas_anode: (str | None) Default gas for anode (only relevant if `anode_flow_module` is utilized)\n        Default: None\n    :param default_gas_cathode: (str | None) Default gas for cathode (only relevant if `cathode_flow_module` is utilized)\n        Default: None\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def switch_open_circuit(self) -&gt; None:\n    \"\"\"\n    Requires `electrical_control_module`\n    Switches to open circuit condition.\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def avg_V(self, duration: float) -&gt; float:\n    \"\"\"\n    Requires `electrical_control_module`\n    Calculates the average voltage measured during a given duration.\n    :param duration: (float) The duration for the averaging process.\n    :return: (float) The average voltage\n    \"\"\"\n</code></pre>"},{"location":"functions/#electrolyzer-only-functions-requiring-electrical_control_module","title":"Electrolyzer-only Functions Requiring <code>electrical_control_module</code>","text":"<pre><code>def set_gas_pressure_anode(self, gas_pressure: float) -&gt; None:\n    \"\"\"\n    Requires `electrical_control_module`; electrolyzer-only function\n    Set the gas pressure of the anode.\n    :param gas_pressure: (float) Gas pressure.\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def set_gas_pressure_cathode(self, gas_pressure: float) -&gt; None:\n    \"\"\"\n    Requires `electrical_control_module`; electrolyzer-only function\n    Set the gas pressure of the cathode.\n    :param gas_pressure: (float) Gas pressure.\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def reset_pressures(self) -&gt; None:\n    \"\"\"\n    Requires `electrical_control_module`; electrolyzer-only function\n    Resets both anode and cathode pressures to 0.\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def read_pressures(self) -&gt; tuple[float, float]:\n    \"\"\"\n    Requires `electrical_control_module`; electrolyzer-only function\n    Reads the anode and cathode pressures.\n    :return: (tuple[float, float]) The anode and cathode pressures\n    \"\"\"\n</code></pre> <pre><code>def read_impurities(self) -&gt; tuple[float, float]:\n    \"\"\"\n    Requires `electrical_control_module`; electrolyzer-only function\n    Reads the anode and cathode impurity levels.\n    :return: (tuple[float, float]) The anode and cathode impurity levels\n    \"\"\"\n</code></pre> <pre><code>def potentiostat_mode(self, duration: float = 360000.0, pause_log: bool = True):\n    \"\"\"\n    Requires `electrical_control_module`\n    Interactive potentiostat mode where the user can manually operate the potentiostat in the middle of a pyFCM run\n    :param duration: (float) Max duration of the manual operation mode (in seconds)\n        Default: 360000.0\n    :param pause_log: (bool) Whether to pause the logging while in manual mode\n        Default: True\n    :return:\n    \"\"\"\n</code></pre>"},{"location":"functions/#functions-requiring-heater_control_module","title":"Functions Requiring <code>heater_control_module</code>","text":"<pre><code>def read_values(self) -&gt; list[float]:\n    \"\"\"\n    Requires `temperature_control_module`\n    Reads the temperature (or other) values. Up to 8 values.\n    :return: (list[float]) List of values that were read\n    \"\"\"\n</code></pre> <pre><code>def set_values(self, temp1: float = np.nan, temp2: float = np.nan, temp3: float = np.nan, temp4: float = np.nan,\n               temp5: float = np.nan, temp6: float = np.nan, temp7: float = np.nan,\n               temp8: float = np.nan) -&gt; None:\n    \"\"\"\n    Requires `heater_control_module`\n    Set the (temperature) values. Up to 8 values can be set.\n    :param temp1: (float) Value 1\n        Default: np.nan\n    :param temp2: (float) Value 2\n        Default: np.nan\n    :param temp3: (float) Value 3\n        Default: np.nan\n    :param temp4: (float) Value 4\n        Default: np.nan\n    :param temp5: (float) Value 5\n        Default: np.nan\n    :param temp6: (float) Value 6\n        Default: np.nan\n    :param temp7: (float) Value 7\n        Default: np.nan\n    :param temp8: (float) Value 8\n        Default: np.nan\n    :return: None\n    \"\"\"\n</code></pre>"},{"location":"functions/#functions-requiring-anode_flow_module-andor-cathode_flow_module","title":"Functions Requiring <code>anode_flow_module</code> and/or <code>cathode_flow_module</code>","text":"<pre><code>def read_flows_anode(self) -&gt; tuple[float, float, str | float | None]:\n    \"\"\"\n    Requires `anode_flow_module`\n    Reads the gas and water flows of the anode.\n    :return: (tuple[float, float, str | float | None]) gas flow, water flow, and gas ID for the anode\n    \"\"\"\n</code></pre> <pre><code>def read_flows_cathode(self) -&gt; tuple[float, float, str | float | None]:\n    \"\"\"\n    Requires `cathode_flow_module`\n    Reads the gas and water flows of the cathode.\n    :return: (tuple[float, float, str | float | None]) gas flow, water flow, and gas ID for the cathode\n    \"\"\"\n</code></pre> <pre><code>def set_gas_flowrate_anode(self, flow: float, gas: str | None = None) -&gt; None:\n    \"\"\"\n    Requires `anode_flow_module`\n    Sets the gas flow rate of the anode.\n    :param flow: (float) The gas flow rate of the anode\n    :param gas: (str | None) The gas ID\n        Default: None\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def set_gas_flowrate_cathode(self, flow: float, gas: str | None = None) -&gt; None:\n    \"\"\"\n    Requires `cathode_flow_module`\n    Sets the gas flow rate of the cathode.\n    :param flow: (float) The gas flow rate of the cathode\n    :param gas: (str | None) The gas ID\n        Default: None\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def set_water_flowrate_anode(self, flow: float) -&gt; None:\n    \"\"\"\n    Requires `anode_flow_module`\n    Sets the water flow rate of the anode.\n    :param flow: (float) The water flow rate of the anode\n    :return: None\n    \"\"\"\n</code></pre> <p><pre><code>def set_water_flowrate_cathode(self, flow: float) -&gt; None:\n    \"\"\"\n    Requires `cathode_flow_module`\n    Sets the water flow rate of the cathode.\n    :param flow: (float) The water flow rate of the cathode\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def reset_gases_anode(self, default_gas: str | None = None) -&gt; None:\n    \"\"\"\n    Requires `anode_flow_module`\n    Resets the pressure of the anode to 0 and switches to the default gas.\n    :param default_gas: (str | None) The default gas for the anode\n        Default: None\n    :return: None\n    \"\"\"\n</code></pre></p> <pre><code>def reset_gases_cathode(self, default_gas: str | None = None) -&gt; None:\n    \"\"\"\n    Requires `cathode_flow_module`\n    Resets the pressure of the cathode to 0 and switches to the default gas.\n    :param default_gas: (str | None) The default gas for the cathode\n        Default: None\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def reset_gases(self, default_gas_anode: str | None = None, default_gas_cathode: str | None = None) -&gt; None:\n    \"\"\"\n    Resets the pressure of the anode to 0 and switches to the default gas.\n    :param default_gas_anode: (str | None) The default gas for the anode\n        Default: None\n    :param default_gas_cathode: (str | None) The default gas for the cathode\n        Default: None\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def switch_to_Ar_anode(self) -&gt; None:\n    \"\"\"\n    Requires `anode_anode_module`\n    Switches the anode gas to Argon\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def switch_to_fuel_anode(self) -&gt; None:\n    \"\"\"\n    Requires `anode_anode_module`\n    Switches the anode gas to fuel\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def switch_to_Ar_cathode(self) -&gt; None:\n    \"\"\"\n    Requires `cathode_anode_module`\n    Switches the cathode gas to Argon\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def switch_to_O2_cathode(self) -&gt; None:\n    \"\"\"\n    Requires `cathode_anode_module`\n    Switches the cathode gas to oxygen\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def switch_to_air_cathode(self) -&gt; None:\n    \"\"\"\n    Requires `cathode_anode_module`\n    Switches the cathode gas to air\n    :return: None\n    \"\"\"\n</code></pre>"},{"location":"functions/#functions-requiring-backpressure_module-and-anode_flow_modulecathode_flow_module","title":"Functions Requiring <code>backpressure_module</code> and <code>anode_flow_module</code>/<code>cathode_flow_module</code>","text":"<pre><code>def read_backpressures(self) -&gt; tuple[float, float]:\n    \"\"\"\n    Requires `backpressure_module`\n    Reads the cathode and anode back-pressures.\n    :return: (tuple[float, float]) Tuple of anode and cathode back-pressures\n    \"\"\"\n</code></pre> <pre><code>def set_bkp_anode(self, pressure_setpoint: float, power: int = 4) -&gt; None:\n    \"\"\"\n    Requires `backpressure_module` and `anode_flow_module`\n    Sets the back-pressure of the anode.\n    :param pressure_setpoint: (float) The back-pressure set point of the anode\n    :param power: (int) Power level of the anode\n        Default: 4\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def set_bkp_cathode(self, pressure_setpoint: float, power: int = 4) -&gt; None:\n    \"\"\"\n    Requires `backpressure_module` and `cathode_flow_module`\n    Sets the back-pressure of the cathode.\n    :param pressure_setpoint: (float) The back-pressure set point of the cathode\n    :param power: (int) Power level of the cathode\n        Default: 4\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def reset_bkp_anode(self) -&gt; None:\n    \"\"\"\n    Requires `backpressure_module`\n    Resets the back-pressure of the anode.\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def reset_bkp_cathode(self) -&gt; None:\n    \"\"\"\n    Requires `backpressure_module`\n    Resets the back-pressure of the cathode.\n    :return: None\n    \"\"\"\n</code></pre>"},{"location":"functions/#functions-requiring-anode_flow_modulecathode_flow_module-and-heater_control_module","title":"Functions Requiring <code>anode_flow_module</code>/<code>cathode_flow_module</code> and <code>heater_control_module</code>","text":"<pre><code>def calculate_and_set_water_flowrate_anode(self, pressure: float, gasflow: float | None = None,\n                                           gas: str | None = None, waterflow_delta: float = 0.0, rH: float = 100.0,\n                                           temp_cell: float | None = None, verbose: bool = False) -&gt; None:\n    \"\"\"\n    Requires `anode_flow_module` and `heater_control_module`\n    Calculates and sets the water flow rate of the anode based on specified gasflow, pressure, temperature,\n    and targeted rH. This utilizes our in-house algorithm.\n    :param pressure: (float) The backpressure pressure of the anode\n    :param gasflow: (float) The gas pressure of the anode\n        Default: None\n    :param gas: (str | None) The gas ID\n        Default: None\n    :param waterflow_delta: (float) Any deviation added to the waterflow rate (correction term).\n        Default: 0.0\n    :param rH: (float) The targeted rH (in percent)\n        Default: 100.0\n    :param temp_cell: (float) Temperature of the cell (in Celsius)\n        Default: None\n    :param verbose: (bool) Whether to print out additional information.\n        Default: False\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def calculate_and_set_water_flowrate_cathode(self, pressure: float, gasflow: float | None = None,\n                                             gas: str | None = None, waterflow_delta: float = 0.0,\n                                             rH: float = 100.0, temp_cell: float | None = None,\n                                             verbose: bool = False) -&gt; None:\n    \"\"\"\n   Requires `cathode_flow_module` and `heater_control_module`\n   Calculates and sets the water flow rate of cathode based on specified gasflow, pressure, temperature,\n   and targeted rH. This utilizes our in-house machine learning model.\n   :param pressure: (float) The backpressure pressure of the cathode\n   :param gasflow: (float) The gas pressure of the cathode\n       Default: None\n   :param gas: (str | None) The gas ID\n       Default: None\n   :param waterflow_delta: (float) Any deviation added to the waterflow rate (correction term).\n       Default: 0.0\n   :param rH: (float) The targeted rH (in percent)\n       Default: 100.0\n   :param temp_cell: (float) Temperature of the cell (in Celsius)\n       Default: None\n   :param verbose: (bool) Whether to print out additional information.\n       Default: False\n   :return: None\n   \"\"\"\n</code></pre>"},{"location":"functions/#functions-requiring-electrical_control_module-and-load_hardware","title":"Functions Requiring <code>electrical_control_module</code> and <code>load_hardware</code>","text":"<pre><code>def OCV(self, duration: float, skipable: bool = False) -&gt; None:\n    \"\"\"\n    Requires `electrical_control_module` and `load_hardware`\n    Put system in open curcuit voltage condition for the specified duration.\n    :param duration: (float) Duration in seconds\n    :param skipable: (bool) Whether to be able to skip the duration (by pressing `end` key on the keyboard)\n        Default: False\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def FC_mode_CC(self, duration: float, load_current: list[float] | float, current_range: int = 40,\n               final_OCV: bool = True, skipable: bool = False, skip_voltage: float | None = None) -&gt; None:\n    \"\"\"\n    Requires `electrical_control_module` and `load_hardware`\n    Fuel cell constant current mode. Go through list of load currents that are held for specified duration.\n    :param duration: (float) Duration in seconds\n    :param load_current: (list[float] | float) List of load currents\n    :param current_range: (int) Current range\n        Default: 40\n    :param final_OCV: (bool) Whether to end in OCV\n        Default: True\n    :param skipable: (bool) Whether to be able to skip current steps (by pressing `end` key on the keyboard)\n        Default: False\n    :param skip_voltage: (float | None) Voltage that determines the skipping trigger\n        Default: None\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def FC_mode_CV(self, duration: float, load_voltage: list[float] | float, current_range: int = 1,\n               final_OCV: bool = True, skipable: bool = False) -&gt; None:\n    \"\"\"\n    Requires `electrical_control_module` and `load_hardware`\n    Fuel cell constant current mode. Go through list of load currents that are held for specified duration.\n    :param duration: (float) Duration in seconds\n    :param load_voltage: (list[float] | float) List of load voltages\n    :param current_range: (int) Current range\n        Default: 1\n    :param final_OCV: (bool) Whether to end in OCV\n        Default: True\n    :param skipable: (bool) Whether to be able to skip current steps (by pressing `end` key on the keyboard)\n        Default: False\n    :return: None\n    \"\"\"\n</code></pre>"},{"location":"functions/#functions-requiring-electrical_control_module-and-potentiostat_hardware","title":"Functions Requiring <code>electrical_control_module</code> and <code>potentiostat_hardware</code>","text":"<pre><code>def cyclic_voltammetry(self, V_start: float, V1: float, V2: float, V_end: float, scan_rate: float, n_cycles: int,\n                       sample_rate: float = 0.01, plot: bool = True) -&gt; None:\n    \"\"\"\n    Requires `electrical_control_module` and `potentiostat_hardware`\n    Cyclic voltammetry protocol from starting to ending voltage with specified number of cycles\n    between V1 and V1 for n_cycles at specified scan rate and sample rate.\n    :param V_start: (float) Starting voltage\n    :param V1: (float) Voltage 1\n    :param V2: (float) Voltage 2\n    :param V_end: (float) Ending voltage\n    :param scan_rate: (float) Scan rate\n    :param n_cycles: (int) Number of cycles\n    :param sample_rate: (float) Sample rate\n        Default: 0.01\n    :param plot: (bool) Whether to generate a plot at the end\n        Default: True\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def CV_potentiostat(self, voltages: list, hold_time: float = 300.0, plot: bool = True) -&gt; None:\n    \"\"\"\n    Requires `electrical_control_module` and `potentiostat_hardware`\n    CV mode with potentiostat for specified list of voltages at specified holding time.\n    :param voltages: (list) List of voltages\n    :param hold_time: (float) Hold time in seconds\n        Default: 300.0\n    :param plot: (bool) Whether to generate a plot at the end\n        Default: True\n    :return: None\n    \"\"\"\n</code></pre> <pre><code>def squarewave_potentiostat(self, voltage1: float, voltage2: float, hold_time_1: float = 3.0,\n                            hold_time_2: float = 3.0, ascend_time: float = 0.1, descend_time: float = 0.1,\n                            n_cycles: int = 10000, plot: bool = True) -&gt; None:\n    \"\"\"\n    Requires `electrical_control_module` and `potentiostat_hardware`\n    Squarewave potentiostat mode between two states of defined voltages, holding times for specified\n    number of cycles with ascending and descending times.\n    :param voltage1: (float) Voltage at state 1\n    :param voltage2: (float) Voltage at state 2\n    :param hold_time_1: (float) Holding time at state 1 in seconds\n        Default: 3.0\n    :param hold_time_2: (float) Holding time at state 2 in seconds\n        Default: 3.0\n    :param ascend_time: (float) Time it takes to ascend, in seconds\n        Default: 0.1\n    :param descend_time: (float) Time it takes to descend, in seconds\n        Default: 0.1\n    :param n_cycles: (int) Number of squarewave cycles\n        Default: 10000\n    :param plot: Whether to generate a plot at the end\n        Default: True\n    :return: None\n    \"\"\"\n</code></pre>"},{"location":"functions/#function-requiring-potentiostat_hardware-load_hardware-and-electrical_control_module","title":"Function Requiring <code>potentiostat_hardware</code>, <code>load_hardware</code>, and <code>electrical_control_module</code>","text":"<pre><code>def EIS_load(self, base_current: float, perturbation_percentage: float, starting_frequency: float = 10000.0,\n             ending_frequency: float = 20.0, points_per_decade: int = 20,\n             base_current_wait: float = 5.0, plot: bool = True) -&gt; None:\n    \"\"\"\n    Requires `potentiostat_hardware`, `load_hardware`, and `electrical_control_module`\n    EIS mode with load and potentiostat for specified base current, perturbation percentage,\n    starting/ending frequency, base current wait time and points per decade.\n    :param base_current: (float) Base current\n    :param perturbation_percentage: (float) Perturbation percentage\n    :param starting_frequency: (float) Starting frequency in Hertz\n        Default: 10000.0\n    :param ending_frequency: (float) Ending frequency in Hertz\n        Default: 20.0\n    :param points_per_decade: (int) Number of points per decade to be collected\n        Default: 20\n    :param base_current_wait: (float) Wait time for base current, in seconds\n        Default: 5.0\n    :param plot: Whether to generate a plot at the end\n        Default: True\n    :return: None\n    \"\"\"\n</code></pre>"},{"location":"init/","title":"Initialization and Usage","text":""},{"location":"init/#start-up-and-shutdown-procedures","title":"Start-up and Shutdown Procedures","text":"<p>In the main folder of the pyFCM suite one can edit the files <code>startup.txt</code> and <code>shutdown.txt</code> to reflect start-up and  shutdown procedures that the user wants the user to follow (add one instruction per line in the txt files).  These instructions will be prompted if the variable <code>startup_instructions</code> is set to <code>True</code> (which is the default).</p>"},{"location":"init/#initialization-of-software-components","title":"Initialization of Software Components","text":"<p>The main class <code>PCM</code> in the <code>process_control_module</code> is the central hub and every hardware component  has its own Python class that needs to be initialized and then passed to the <code>PCM</code> class as a variable for initialization.</p> <p>To illustrate this, below we will give a few examples:</p> <ul> <li> <p>Electrolyzer with <code>electrical_control_module</code> provided <pre><code>from pyFCM.process_control_module import PCM\nfrom pyFCM.electrical_control_module import LCM\nfrom pyFCM.data_acquisition_hardware import DAQ\n\n# Software initialization\ndaq = DAQ()\nlcm = LCM(daq)\n\npcm = PCM(electrical_module=lcm,\n          sample_id=\"test\"\n          )\n\n# Software initialization complete, runs starts below:\npcm.wait(duration=5)\npcm.set_gas_pressure_anode(gas_pressure=0.5)\npcm.set_gas_pressure_cathode(gas_pressure=0.5)\npcm.wait(duration=5)\npcm.hardware_reset()\n# End of test run\n</code></pre></p> </li> <li> <p>Fuel Cell with <code>electrical_control_module</code>, <code>load_hardware</code>, <code>anode_flow_module</code>, and <code>cathode_flow_module</code> provided <pre><code>from pyFCM.process_control_module import PCM\nfrom pyFCM.electrical_control_module import ECM\nfrom pyFCM.data_acquisition_hardware import DAQ\nfrom pyFCM.anode_flow_module import AFM\nfrom pyFCM.cathode_flow_module import CFM\nfrom pyFCM.load_hardware import Load\n\n# Software initialization\ndaq = DAQ()\necm = ECM(daq)\nafm = AFM()\ncfm = CFM()\nlh = Load()\n\npcm = PCM(heater_module=None,\n          anode_module=afm,\n          cathode_module=cfm,\n          electrical_module=ecm,\n          load_module=lh,\n          potentiostat_module=None,\n          sample_id=\"test123\"\n          )\n\n# Software initialization complete, runs starts below:\npcm.wait(duration=5)\npcm.switch_to_Ar_anode()\npcm.switch_to_fuel_anode()\npcm.set_gas_flowrate_anode(flow=0.5)\npcm.set_gas_flowrate_cathode(flow=0.5)\npcm.wait(duration=5)\npcm.FC_mode_CC(duration=10, load_current=[0.1, 0.2, 0.5])\npcm.wait(duration=5)\npcm.hardware_reset()\n# End of test run\n</code></pre></p> </li> </ul> <p>A full list of available function (depending on which hardware is available at the user) can be found here.</p>"}]}